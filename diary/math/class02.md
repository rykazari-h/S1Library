# 04/14まとめ:石川巧真くんの誕生日です。
## やったこと（今年の九大(今までで一番簡単だったそうです)）
### 問1
1. $`n`$を整数とするとき、$`n^2`$を8で割った余りは$`0,1,4`$のいずれかであることを示せ。
2. $`2^m=n^2+3`$をみたす0以上の整数の組$`(m,n)`$をすべて求めよ。
* 1-  
	$`n`$を$`8`$で割った余りが$`0,1,2,3,4,5,6,7`$であるとき、$`n^2`$を$`8`$で割った余りはそれぞれ$`0,1,4,1,0,1,4,1`$となる。よって、$`n^2`$を$`8`$で割った余りは$`0,1,4`$のいずれかである。   
* 2-  
	1-より、$`(n^2+3)mod8`$は、$`3,4,7`$のいずれかであるので、左辺についてmは3以下である。よって、範囲内のすべてのmについて条件を満たすnが存在するか確かめればよく、$`(m,n)=(2,1)`$  
### 問2
幾何問題で、簡単だしめんどいので省略
## 心構え
* 不等式はてーねーてーねーに場合分けしてとこう。  
* 二次不等式の問題とかは、ものによってはグラフを使って解くのもありかもしれない。
## 最後に
石川巧真くん入緑と生誕16周年おめでとう！
# 04/20まとめ
### 何もしていない
## 順列(next_permutation)について
次の順列を見る時、あるインデックスi未満が変わって、i以上が変わらないということは起こりえません。よって、a[i]＜a[i+1]となるiを見つけ、a[i]より大きい数を探せばいいということがわかります。それらをスワップしたあとに、i以降の配列を昇順にするには、O(nlog(n))かける必要はなく、前の順列のi以降が降順に並んでいることからO(n)でreverseすれば良いとわかります。c++ではイテレータやテンプレートを使えるので、以下のように簡潔に実装できます。
```cpp:next_permutation.h
namespace rhyska{
	template<class I,class C>
	bool next_premutation(I f,I l,C c){
		auto sw=[&](I a,I b){auto t=*a;*a=*b;*b=t;};
		auto rev=[&](I a,I b){for(--b;a<b;++a,--b)sw(a,b);};
		if(f==l)return 0;
		I i=l;--i;
		if(f==i)return 0;
		for(;;){
			I si=i;--i;
			if(c(*i,*si)){
				I j=l;
				while(!c(*i,*--j));
				sw(i,j);
				rev(si,l);
				return 1;
			}
			if(i==f){
				rev(f,l);
				return 0;
			}
		}
	}
	template<class I,class T>
	bool next_permutaion(I f,I l){
		return next_permutation(f,l,[](T a,T b){return a<b;});
	}
}
```
## 最後に
ごとうこたろう怒られてて草
