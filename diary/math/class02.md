# 04/14まとめ:石川巧真くんの誕生日です。
## やったこと（今年の九大(今までで一番簡単だったそうです)）
### 問1
1. $`n`$を整数とするとき、$`n^2`$を8で割った余りは$`0,1,4`$のいずれかであることを示せ。
2. $`2^m=n^2+3`$をみたす0以上の整数の組$`(m,n)`$をすべて求めよ。
* 1-  
	$`n`$を$`8`$で割った余りが$`0,1,2,3,4,5,6,7`$であるとき、$`n^2`$を$`8`$で割った余りはそれぞれ$`0,1,4,1,0,1,4,1`$となる。よって、$`n^2`$を$`8`$で割った余りは$`0,1,4`$のいずれかである。   
* 2-  
	1-より、$`(n^2+3)mod8`$は、$`3,4,7`$のいずれかであるので、左辺についてmは3以下である。よって、範囲内のすべてのmについて条件を満たすnが存在するか確かめればよく、$`(m,n)=(2,1)`$  
### 問2
幾何問題で、簡単だしめんどいので省略
## 心構え
* 不等式はてーねーてーねーに場合分けしてとこう。  
* 二次不等式の問題とかは、ものによってはグラフを使って解くのもありかもしれない。
## 最後に
石川巧真くん入緑と生誕16周年おめでとう！
# 04/20まとめ
### 何もしていない
## 順列(next_permutation)について
次の順列を見る時、あるインデックスi未満が変わって、i以上が変わらないということは起こりえません。よって、a[i]＜a[i+1]となるiを見つけ、a[i]より大きい数を探せばいいということがわかります。それらをスワップしたあとに、i以降の配列を昇順にするには、O(nlog(n))かける必要はなく、前の順列のi以降が降順に並んでいることからO(n)でreverseすれば良いとわかります。c言語で実装すると、次のようになります(int配列の順列)
```c:next_permutation.c
void swap(int*a,int*b){
	int t=*a;
	*a=*b;
	*b=t;
}
void reverse(int*a,int*b){
	--b;
	while(a<b)swap(a++,b--);
}

int next_permutation(int*first,int*last) {
	if(first==last)return 0;
	int*i=last-1;
	if(first==i)return 0;
	for(;;){
		int*ii=i--;
		if(*i<*ii){
			int*j=last;
			while(!(*i<*--j));
			swap(i,j);
			reverse(ii,last);
			return 1;
		}
		if(i==first){
			reverse(first,last);
			return 0;
		}
	}
}
```
## 最後に
ごとうこたろう怒られてて草
